package resources

import (
	"fmt"
	"go/format"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/cruffinoni/rimworld-editor/cmd/app/ui/term/printer"
	"github.com/iancoleman/strcase"

	"github.com/cruffinoni/rimworld-editor/file"
	"github.com/cruffinoni/rimworld-editor/generator"
	"github.com/cruffinoni/rimworld-editor/generator/files"
	"github.com/cruffinoni/rimworld-editor/resources/discover"
	"github.com/cruffinoni/rimworld-editor/xml"
)

type GameData struct {
	fileData       map[string]*GroupedThematic
	accessibleData any
}

type GroupedThematic struct {
	elements map[string]*xml.Element
	cap      int
	mv       generator.MemberVersioning
	roots    []*generator.StructInfo
}

func NewGameData() *GameData {
	return &GameData{
		fileData: make(map[string]*GroupedThematic),
	}
}

func (g *GameData) PrintThemes() {
	log.Println("Game fileData themes:")
	for theme, elements := range g.fileData {
		log.Printf("  %s: %d elements", theme, elements.cap)
	}
}

func (g *GameData) DiscoverGameData(opeSystem string) error {
	gp, err := discover.GetGamePath(opeSystem)
	if err != nil {
		return err
	}
	gp = filepath.Join(gp, "Data")
	log.Println(gp)
	err = filepath.Walk(gp, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return fmt.Errorf("error walking %s: %w", path, err)
		}
		if info.IsDir() {
			return nil
		}
		if !strings.HasSuffix(info.Name(), ".xml") {
			return nil
		}
		var f *file.Opening
		f, err = file.Open(path)
		if err != nil {
			return fmt.Errorf("error opening %s: %w", path, err)
		}
		dir := filepath.Base(filepath.Dir(path))
		// log.Printf("Full dir of %s: %s", dir, filepath.Dir(path))
		if g.fileData[dir] == nil {
			g.fileData[dir] = &GroupedThematic{elements: make(map[string]*xml.Element)}
		}
		g.fileData[dir].elements[path] = f.XML.Root
		return nil
	})
	if err != nil {
		return err
	}
	return nil
}

func (gp *GroupedThematic) mergeMemberVersioning(from generator.MemberVersioning) {
	if gp.mv == nil {
		gp.mv = make(generator.MemberVersioning)
	}
	for k, v := range from {
		gp.mv[k] = append(gp.mv[k], v...)
	}
}

func (g *GameData) generateRegisteredTypeFile() error {
	var (
		f   *os.File
		err error
	)
	basePath := "./resources/generated/"
	githubPath := "github.com/cruffinoni/rimworld-editor/resources/generated/"
	if f, err = os.Create(basePath + "global_game_type.go"); err != nil {
		return err
	}
	body := strings.Builder{}
	header := strings.Builder{}
	fullFileContent := strings.Builder{}
	fullFileContent.WriteString("// Code generated by rimworld-editor. DO NOT EDIT.\n\n")
	fullFileContent.WriteString("package generated_resources\n\n")
	header.WriteString("import (\n")
	body.WriteString("var GlobalGameData = map[string]any {\n")
	for p := range g.fileData {
		log.Printf("-> %v", p)
		header.WriteString("\t\"" + githubPath + p + "\"\n")
		body.WriteString("\t\"" + p + "\": " + strcase.ToSnake(p) + ".GeneratedStructStarter0{},\n")
	}
	body.WriteString("\n}")
	header.WriteString("\n)\n")
	var buffer []byte
	fullFileContent.WriteString(header.String())
	fullFileContent.WriteString(body.String())
	buffer, err = format.Source([]byte(fullFileContent.String()))
	if err != nil {
		log.Printf("Err: Format buffer:\n%s", fullFileContent.String())
		return err
	}
	if _, err = f.Write(buffer); err != nil {
		return err
	}
	return nil
}

func (g *GameData) GenerateGoFiles() error {
	basePath := "./resources/generated/"
	if _, err := os.Stat(basePath); err == nil {
		if err = os.RemoveAll(basePath); err != nil {
			return err
		}
	}
	for p := range g.fileData {
		printer.PrintSf("[%s] Processing {-BOLD,F_RED}%d{-RESET} element(s) ...", p, len(g.fileData[p].elements))
		for _, element := range g.fileData[p].elements {
			root := generator.GenerateGoFiles(element, false)
			g.fileData[p].mergeMemberVersioning(generator.RegisteredMembers)
			g.fileData[p].roots = append(g.fileData[p].roots, root)
		}
		generator.FixRegisteredMembers(g.fileData[p].mv)
		for _, r := range g.fileData[p].roots {
			gw := files.NewGoWriter(g.fileData[p].mv, false, strcase.ToSnake(p))
			if err := gw.WriteGoFile(basePath+p, r); err != nil {
				log.Fatal(err)
			}
		}
	}
	return g.generateRegisteredTypeFile()
}

func (g *GameData) ReadGameFiles() {

}
