package generator

import (
	"github.com/cruffinoni/rimworld-editor/xml"
	"github.com/cruffinoni/rimworld-editor/xml/saver"
	"github.com/iancoleman/strcase"
	"go/format"
	"log"
	"os"
	"reflect"
	"strings"
)

func getTypeName(t any) string {
	if t == nil {
		panic("nil type")
	}
	switch va := t.(type) {
	case reflect.Kind:
		return va.String()
	case *CustomType:
		var s strings.Builder
		s.WriteString(va.pkg + "." + va.name + "[" + getTypeName(va.type1))
		if va.type2 != nil {
			s.WriteString(", " + getTypeName(va.type2))
		}
		s.WriteString("]")
		return s.String()
	case *StructInfo:
		return "*" + strcase.ToCamel(va.name)
	case *xml.Element:
		return "*xml.Element"
	default:
		panic("unknown type")
	}
}

func checkTypeAndApply(t any, buffer *buffer, path string) error {
	switch va := t.(type) {
	case *StructInfo:
		return va.generateStructTo(path)
	case *xml.Element:
		buffer.writeImport(headerXml)
	case *CustomType:
		var err error
		if err = checkTypeAndApply(va.type1, buffer, path); err != nil {
			return err
		}
		if va.type2 != nil {
			if err = checkTypeAndApply(va.type2, buffer, path); err != nil {
				return err
			}
		}
	}
	return nil
}

func writeHeader(b *buffer) {
	b.writeToHeader("// Code generated by rimworld-editor. DO NOT EDIT.\n\n")
	b.writeToHeader("package generated\n\n")
}

func (s *StructInfo) generateStructTo(path string) error {
	f, err := os.Create(path + "/" + strcase.ToSnake(s.name) + ".go")
	if err != nil {
		return err
	}
	buf := &buffer{
		writtenHeaders: make(map[string]bool),
	}
	writeHeader(buf)
	defer func(f *os.File) {
		err = f.Close()
		if err != nil {
			log.Fatalf("generator.StructInfo.generateStructTo: can't close the file %v", err)
		}
	}(f)
	structName := strcase.ToCamel(s.name)
	buf.writeToBody("type " + structName + " struct {\n")
	for _, m := range s.members {
		buf.writeToBody("\t" + strcase.ToCamel(m.name) + " ")
		switch va := m.t.(type) {
		case *CustomType:
			buf.writeImport(va.importPath)
			buf.writeToBody(va.pkg + "." + va.name + "[" + getTypeName(va.type1))
			if err = checkTypeAndApply(va.type1, buf, path); err != nil {
				return err
			}
			if va.type2 != nil {
				if err = checkTypeAndApply(va.type2, buf, path); err != nil {
					return err
				}
				buf.writeToBody(", " + getTypeName(va.type2))
			}
			buf.writeToBody("]")
		case reflect.Kind:
			buf.writeToBody(va.String())
		case *StructInfo:
			buf.writeToBody("*" + strcase.ToCamel(va.name))
			if err = va.generateStructTo(path); err != nil {
				return err
			}
		case *xml.Element:
			// headerXml will be imported in the buffer when we write the
			// required import statement.
			//buf.writeImport(headerXml)
			buf.writeToBody("*xml.Element")
		}
		buf.writeToBody(" `xml:\"" + m.name + "\"`\n")
	}
	buf.writeToFooter("}\n")
	writeRequiredInterfaces(buf, structName)
	var b []byte
	b, err = format.Source(buf.bytes())
	if err != nil {
		log.Printf("Err: Format buffer:\n%s", buf.bytes())
		return err
	}
	if _, err = f.Write(b); err != nil {
		return err
	}
	return nil
}

type require interface {
	saver.Transformer
	xml.Assigner
}

var (
	tRequired = reflect.TypeOf((*require)(nil)).Elem()
	nbMethod  = tRequired.NumMethod()
)

func writeRequiredInterfaces(b *buffer, structName string) {
	b.writeImport(saverPath, xmlAttributes, headerXml)
	for i := 0; i < nbMethod; i++ {
		m := tRequired.Method(i)
		b.writeToFooter("" +
			"func (" + strings.ToLower(structName[:1]) + " *" + structName + ") ")
		b.writeToFooter(m.Name + "(")
		if m.Type.NumIn() > 0 {
			totalIn := m.Type.NumIn()
			for j := 0; j < totalIn; j++ {
				if j > 0 {
					b.writeToFooter(", ")
				}
				b.writeToFooter(m.Type.In(j).String())
			}
		}
		b.writeToFooter(")")
		numReturnedValue := m.Type.NumOut()
		returnedValue := make([]reflect.Type, 0, numReturnedValue)
		if numReturnedValue > 0 {
			if numReturnedValue > 1 {
				b.writeToFooter(" (")
			}
			for j := 0; j < numReturnedValue; j++ {
				if j > 0 {
					b.writeToFooter(", ")
				}
				o := m.Type.Out(j)
				returnedValue = append(returnedValue, o)
				b.writeToFooter(o.String())
			}
			if numReturnedValue > 1 {
				b.writeToFooter(")")
			}
		}
		b.writeToFooter(" {\n")
		b.writeToFooter("\treturn ")
		if numReturnedValue > 0 {
			for c, rt := range returnedValue {
				if c > 0 {
					b.writeToFooter(", ")
				}
				switch rt.Kind() {
				case reflect.Bool:
					b.writeToFooter("false")
				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
					b.writeToFooter("0")
				case reflect.Float32, reflect.Float64:
					b.writeToFooter("0.0")
				case reflect.String:
					b.writeToFooter(`""`)
				case reflect.Pointer, reflect.Interface, reflect.Slice, reflect.Array, reflect.Map:
					b.writeToFooter("nil")
				default:
					log.Panicf("generator.StructInfo.writeRequiredInterfaces: unknown type %v", rt.Kind())
				}
			}
		}
		b.writeToFooter("}\n")
	}
}
