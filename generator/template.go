package generator

import (
	"github.com/cruffinoni/rimworld-editor/xml"
	"github.com/iancoleman/strcase"
	"go/format"
	"log"
	"os"
	"reflect"
	"strings"
)

type bufferTemplate struct {
	writtenHeaders map[string]bool
	header         string
	body           string
	footer         string
}

const (
	headerXmlTypes = "xml/types"
	headerXml      = "xml"
)

func (t *bufferTemplate) writeImport(s string) {
	if v, ok := t.writtenHeaders[s]; ok && v {
		return
	}
	t.writtenHeaders[s] = true
	t.header += `import "github.com/cruffinoni/rimworld-editor/` + s + `"` + "\n"
}

func (t *bufferTemplate) writeToHeader(s string) {
	t.header += s
}

func (t *bufferTemplate) writeToBody(s string) {
	t.body += s
}

func (t *bufferTemplate) writeToFooter(s string) {
	t.footer += s
}

func (t *bufferTemplate) bytes() []byte {
	return []byte(t.header + t.body + t.footer)
}

func getTypeName(t any) string {
	if t == nil {
		panic("nil type")
	}
	switch va := t.(type) {
	case reflect.Kind:
		return va.String()
	case *customType:
		var s strings.Builder
		s.WriteString(va.pkg + "." + va.name + "[" + getTypeName(va.types1))
		if va.types2 != nil {
			s.WriteString(", " + getTypeName(va.types2))
		}
		s.WriteString("]")
		return s.String()
	case *StructInfo:
		return "*" + strcase.ToCamel(va.name)
	case *xml.Element:
		return "*xml.Element"
	default:
		panic("unknown type")
	}
}

func checkTypeAndApply(t any, buffer *bufferTemplate, path string) error {
	switch va := t.(type) {
	case *StructInfo:
		return va.generateStructTo(path)
	case *xml.Element:
		buffer.writeImport(headerXml)
	case *customType:
		var err error
		if err = checkTypeAndApply(va.types1, buffer, path); err != nil {
			return err
		}
		if va.types2 != nil {
			if err = checkTypeAndApply(va.types2, buffer, path); err != nil {
				return err
			}
		}
	}
	return nil
}

func (s *StructInfo) generateStructTo(path string) error {
	f, err := os.Create(path + "/" + strcase.ToSnake(s.name) + ".go")
	if err != nil {
		return err
	}
	var (
		buffer = &bufferTemplate{
			writtenHeaders: make(map[string]bool),
		}
	)
	buffer.writeToHeader("// Code generated by rimworld-editor. DO NOT EDIT.\n\n")
	buffer.writeToHeader("package generated\n\n")
	defer f.Close()
	buffer.writeToBody("type " + strcase.ToCamel(s.name) + " struct {\n")
	for _, m := range s.members {
		buffer.writeToBody("\t" + strcase.ToCamel(m.name) + " ")
		switch va := m.t.(type) {
		case *customType:
			buffer.writeImport(headerXmlTypes)
			buffer.writeToBody(va.pkg + "." + va.name + "[" + getTypeName(va.types1))
			if err = checkTypeAndApply(va.types1, buffer, path); err != nil {
				return err
			}
			if va.types2 != nil {
				if err = checkTypeAndApply(va.types2, buffer, path); err != nil {
					return err
				}
				buffer.writeToBody(", " + getTypeName(va.types2))
			}
			buffer.writeToBody("]")
		case reflect.Kind:
			buffer.writeToBody(va.String())
		case *StructInfo:
			buffer.writeToBody("*" + strcase.ToCamel(va.name))
			if err = va.generateStructTo(path); err != nil {
				return err
			}
		case *xml.Element:
			buffer.writeImport(headerXml)
			buffer.writeToBody("*xml.Element")
		}
		buffer.writeToBody(" `xml:\"" + m.name + "\"`\n")
	}
	buffer.writeToFooter("}\n")
	var b []byte
	//log.Printf("Formatting %s...", path+"/"+strcase.ToSnake(s.name)+".go")
	b, err = format.Source(buffer.bytes())
	if err != nil {
		log.Printf("Err: Bytes buffer:\n%s", buffer.bytes())
		return err
	}
	if _, err = f.Write(b); err != nil {
		return err
	}
	return nil
}
