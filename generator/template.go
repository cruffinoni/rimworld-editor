package generator

import (
	"github.com/cruffinoni/rimworld-editor/xml"
	"github.com/iancoleman/strcase"
	"go/format"
	"log"
	"os"
	"reflect"
	"strings"
)

func getTypeName(t any) string {
	if t == nil {
		panic("nil type")
	}
	switch va := t.(type) {
	case reflect.Kind:
		return va.String()
	case *CustomType:
		var s strings.Builder
		s.WriteString(va.pkg + "." + va.name + "[" + getTypeName(va.type1))
		if va.type2 != nil {
			s.WriteString(", " + getTypeName(va.type2))
		}
		s.WriteString("]")
		return s.String()
	case *StructInfo:
		return "*" + strcase.ToCamel(va.name)
	case *xml.Element:
		return "*xml.Element"
	default:
		panic("unknown type")
	}
}

func checkTypeAndApply(t any, buffer *buffer, path string) error {
	switch va := t.(type) {
	case *StructInfo:
		return va.generateStructTo(path)
	case *xml.Element:
		buffer.writeImport(headerXml)
	case *CustomType:
		var err error
		if err = checkTypeAndApply(va.type1, buffer, path); err != nil {
			return err
		}
		if va.type2 != nil {
			if err = checkTypeAndApply(va.type2, buffer, path); err != nil {
				return err
			}
		}
	}
	return nil
}

func (s *StructInfo) generateStructTo(path string) error {
	f, err := os.Create(path + "/" + strcase.ToSnake(s.name) + ".go")
	if err != nil {
		return err
	}
	buf := &buffer{
		writtenHeaders: make(map[string]bool),
	}
	buf.writeToHeader("// Code generated by rimworld-editor. DO NOT EDIT.\n\n")
	buf.writeToHeader("package generated\n\n")
	defer func(f *os.File) {
		err = f.Close()
		if err != nil {
			log.Fatalf("generator.StructInfo.generateStructTo: can't close the file %v", err)
		}
	}(f)
	buf.writeToBody("type " + strcase.ToCamel(s.name) + " struct {\n")
	for _, m := range s.members {
		buf.writeToBody("\t" + strcase.ToCamel(m.name) + " ")
		switch va := m.t.(type) {
		case *CustomType:
			buf.writeImport(headerXmlTypes)
			buf.writeToBody(va.pkg + "." + va.name + "[" + getTypeName(va.type1))
			if err = checkTypeAndApply(va.type1, buf, path); err != nil {
				return err
			}
			if va.type2 != nil {
				if err = checkTypeAndApply(va.type2, buf, path); err != nil {
					return err
				}
				buf.writeToBody(", " + getTypeName(va.type2))
			}
			buf.writeToBody("]")
		case reflect.Kind:
			buf.writeToBody(va.String())
		case *StructInfo:
			buf.writeToBody("*" + strcase.ToCamel(va.name))
			if err = va.generateStructTo(path); err != nil {
				return err
			}
		case *xml.Element:
			buf.writeImport(headerXml)
			buf.writeToBody("*xml.Element")
		}
		buf.writeToBody(" `xml:\"" + m.name + "\"`\n")
	}
	buf.writeToFooter("}\n")
	var b []byte
	b, err = format.Source(buf.bytes())
	if err != nil {
		log.Printf("Err: Format buffer:\n%s", buf.bytes())
		return err
	}
	if _, err = f.Write(b); err != nil {
		return err
	}
	return nil
}
