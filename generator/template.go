package generator

import (
	"fmt"
	"go/format"
	"log"
	"os"
	"reflect"
	"strings"

	"github.com/iancoleman/strcase"

	"github.com/cruffinoni/rimworld-editor/algorithm"
	"github.com/cruffinoni/rimworld-editor/xml"
)

func getTypeName(t any) string {
	if t == nil {
		panic("nil type")
	}
	switch va := t.(type) {
	case reflect.Kind:
		return va.String()
	case *CustomType:
		var s strings.Builder
		if va.name == "Empty" {
			s.WriteString(va.pkg + "." + va.name)
			return s.String()
		}
		s.WriteString(va.pkg + "." + va.name + "[" + getTypeName(va.type1))
		if va.type2 != nil {
			s.WriteString(", " + getTypeName(va.type2))
		}
		s.WriteString("]")
		return s.String()
	case *StructInfo:
		return "*" + strcase.ToCamel(va.name)
	case *xml.Element:
		return "*xml.Element"
	default:
		panic("unknown type")
	}
}

func checkTypeAndApply(t any, buffer *buffer, path string) error {
	switch va := t.(type) {
	case *StructInfo:
		return va.generateStructToPath(path)
	case *xml.Element:
		buffer.writeImport(headerXml)
	case *CustomType:
		var err error
		buffer.writeImport(va.importPath)
		if err = checkTypeAndApply(va.type1, buffer, path); err != nil {
			return err
		}
		if va.type2 != nil {
			if err = checkTypeAndApply(va.type2, buffer, path); err != nil {
				return err
			}
		}
	}
	return nil
}

func writeHeader(b *buffer) {
	b.writeToHeader("// Code generated by rimworld-editor. DO NOT EDIT.\n\n")
	b.writeToHeader("package generated\n\n")
}

func removeInnerKeyword(s string) string {
	return strings.Replace(s, InnerKeyword, "", -1)
}

func writeCustomType(c *CustomType, b *buffer, path string) error {
	var err error
	b.writeImport(c.importPath)
	//log.Printf("Custom type %+v", *c)
	b.writeToBody(c.pkg + "." + c.name)
	if c.type1 == nil {
		//log.Printf("Types: %v & %v", c.type1, c.type2)
		return nil
	}
	b.writeToBody("[" + getTypeName(c.type1))
	if err = checkTypeAndApply(c.type1, b, path); err != nil {
		return err
	}
	if c.type2 != nil {
		if err = checkTypeAndApply(c.type2, b, path); err != nil {
			return err
		}
		b.writeToBody(", " + getTypeName(c.type2))
	}
	b.writeToBody("]")
	return err
}

func (s *StructInfo) generateStructToPath(path string) error {
	f, err := os.Create(path + "/" + strcase.ToSnake(s.name) + ".go")
	if err != nil {
		return err
	}
	buf := &buffer{
		writtenHeaders: make(map[string]bool),
	}
	writeHeader(buf)
	defer func(f *os.File) {
		err = f.Close()
		if err != nil {
			log.Fatalf("generator.StructInfo.generateStructToPath: can't close the file %v", err)
		}
	}(f)
	structName := strcase.ToCamel(s.name)
	buf.writeToBody("type " + structName + " struct {\n")
	for _, m := range s.members {
		buf.writeToBody("\t" + strcase.ToCamel(m.name) + " ")
		switch va := m.t.(type) {
		case *CustomType:
			if err = writeCustomType(va, buf, path); err != nil {
				return err
			}
		case reflect.Kind:
			buf.writeToBody(va.String())
		case *StructInfo:
			buf.writeToBody("*" + strcase.ToCamel(va.name))
			if s.name == va.name {
				return fmt.Errorf("duplicate name for %s", s.name)
			}
			if err = va.generateStructToPath(path); err != nil {
				return err
			}
		case *xml.Element:
			// headerXml will be imported in the buffer when we write the
			// required import statement.
			buf.writeToBody("*xml.Element")
		}
		buf.writeToBody(" `xml:\"" + removeInnerKeyword(m.name) + "\"`\n")
	}
	buf.writeToFooter("}\n")
	writeRequiredInterfaces(buf, structName)
	var b []byte
	b, err = format.Source(buf.bytes())
	if err != nil {
		log.Printf("Err: Format buffer:\n%s", buf.bytes())
		return err
	}
	if _, err = f.Write(b); err != nil {
		return err
	}
	return nil
}

type generic struct{}

type require interface {
	xml.Assigner
	algorithm.Comparable[generic]
}

var (
	tRequired        = reflect.TypeOf((*require)(nil)).Elem()
	nbRequiredMethod = tRequired.NumMethod()

	localGenericName = reflect.TypeOf(generic{}).Name()
)

func writeRequiredInterfaces(b *buffer, structName string) {
	b.writeImport(xmlAttributes, headerXml)
	for i := 0; i < nbRequiredMethod; i++ {
		m := tRequired.Method(i)
		b.writeToFooter("\n" +
			"func (" + strings.ToLower(structName[:1]) + " *" + structName + ") ")
		b.writeToFooter(m.Name + "(")
		if m.Type.NumIn() > 0 {
			totalIn := m.Type.NumIn()
			for j := 0; j < totalIn; j++ {
				if j > 0 {
					b.writeToFooter(", ")
				}
				if localGenericName == m.Type.In(j).Name() {
					b.writeToFooter("*" + structName)
				} else {
					b.writeToFooter(m.Type.In(j).String())
				}
			}
		}
		b.writeToFooter(")")
		numReturnedValue := m.Type.NumOut()
		returnedValue := make([]reflect.Type, 0, numReturnedValue)
		if numReturnedValue > 0 {
			if numReturnedValue > 1 {
				b.writeToFooter(" (")
			}
			for j := 0; j < numReturnedValue; j++ {
				if j > 0 {
					b.writeToFooter(", ")
				}
				o := m.Type.Out(j)
				if o.Name() == localGenericName {
					returnedValue = append(returnedValue, reflect.TypeOf((*require)(nil)))
					b.writeToFooter("*" + structName)
				} else {
					returnedValue = append(returnedValue, o)
					b.writeToFooter(o.String())
				}
			}
			if numReturnedValue > 1 {
				b.writeToFooter(")")
			}
		}
		b.writeToFooter(" {\n")
		b.writeToFooter("\treturn ")
		if numReturnedValue > 0 {
			for c, rt := range returnedValue {
				if c > 0 {
					b.writeToFooter(", ")
				}
				switch rt.Kind() {
				case reflect.Bool:
					b.writeToFooter("false")
				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
					b.writeToFooter("0")
				case reflect.Float32, reflect.Float64:
					b.writeToFooter("0.0")
				case reflect.String:
					b.writeToFooter(`""`)
				case reflect.Pointer, reflect.Interface, reflect.Slice, reflect.Array, reflect.Map:
					b.writeToFooter("nil")
				default:
					log.Panicf("generator.StructInfo.writeRequiredInterfaces: unknown type %v", rt.Kind())
				}
			}
		}
		b.writeToFooter("}\n")
	}
}
