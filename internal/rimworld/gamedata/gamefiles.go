package gamedata

import (
	"fmt"
	"go/format"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/iancoleman/strcase"

	"github.com/cruffinoni/rimworld-editor/internal/codegen"
	"github.com/cruffinoni/rimworld-editor/internal/codegen/writer"
	"github.com/cruffinoni/rimworld-editor/internal/rimworld/discovery"
	"github.com/cruffinoni/rimworld-editor/internal/xml/domain"
	"github.com/cruffinoni/rimworld-editor/internal/xml/loader"
	"github.com/cruffinoni/rimworld-editor/pkg/logging"
)

type GameData struct {
	fileData       map[string]*GroupedThematic
	accessibleData any
	logger         logging.Logger
}

type GroupedThematic struct {
	elements    map[string]*domain.Element
	cap         int
	mv          codegen.MemberVersioning
	structInfos []*codegen.StructInfo
}

func NewGameData(logger logging.Logger) *GameData {
	return &GameData{
		fileData: make(map[string]*GroupedThematic),
		logger:   logger,
	}
}

func (g *GameData) PrintThemes() {
	g.logger.Debug("Game data themes")
	for theme, elements := range g.fileData {
		g.logger.WithFields(logging.Fields{
			"theme":   theme,
			"entries": elements.cap,
		}).Debug("Game data theme")
	}
}

func (g *GameData) DiscoverGameData(opeSystem string) error {
	gp, err := discovery.GetGamePath(opeSystem)
	if err != nil {
		return err
	}
	g.logger.WithField("path", gp).Debug("Game path detected")
	err = filepath.Walk(gp, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return fmt.Errorf("error walking %s: %w", path, err)
		}
		if info.IsDir() {
			return nil
		}
		if info.Name() == "About" {
			return nil
		}
		if !strings.HasSuffix(info.Name(), ".xml") {
			return nil
		}
		var f *loader.Opening
		f, err = loader.Open(path)
		if err != nil {
			return fmt.Errorf("error opening %s: %w", path, err)
		}
		// There is a case where we have "StoryTeller" and "Storyteller" for the same type of data
		// So we set the directory name to lower before using ToCamel
		dir := strcase.ToCamel(strings.ToLower(filepath.Base(filepath.Dir(path))))
		//printer.Debugf("Full dir of %s: %s", dir, filepath.Dir(path))
		if g.fileData[dir] == nil {
			g.fileData[dir] = &GroupedThematic{elements: make(map[string]*domain.Element)}
		}
		g.fileData[dir].elements[path] = f.XML.Root
		return nil
	})
	if err != nil {
		return err
	}
	return nil
}

func (gp *GroupedThematic) mergeMemberVersioning(from codegen.MemberVersioning) {
	if gp.mv == nil {
		gp.mv = make(codegen.MemberVersioning)
	}
	for k, v := range from {
		gp.mv[k] = append(gp.mv[k], v...)
	}
}

const generatedFolderBasePath = "./internal/rimworld/gamedata/generated/"

func (g *GameData) generateRegisteredTypeFile() error {
	var (
		f   *os.File
		err error
	)
	githubPath := "github.com/cruffinoni/rimworld-editor/internal/rimworld/gamedata/generated/"
	if f, err = os.Create(generatedFolderBasePath + "global_game_type.go"); err != nil {
		return err
	}
	defer f.Close()
	body := strings.Builder{}
	header := strings.Builder{}
	fullFileContent := strings.Builder{}
	fullFileContent.WriteString("// Code generated by rimworld-editor. DO NOT EDIT.\n\n")
	fullFileContent.WriteString("package generated_resources\n\n")
	header.WriteString("import (\n")
	body.WriteString("var GlobalGameData = map[string]multiple {\n")
	for p := range g.fileData {
		//printer.Debugf("-> %v", p)
		header.WriteString("\t\"" + githubPath + p + "\"\n")
		body.WriteString("\t\"" + p + "\": &" + strcase.ToSnake(p) + ".GeneratedStructStarter0{},\n")
	}
	body.WriteString("\n}")
	header.WriteString("\n)\n")
	var buffer []byte
	fullFileContent.WriteString(header.String())
	fullFileContent.WriteString(body.String())
	buffer, err = format.Source([]byte(fullFileContent.String()))
	if err != nil {
		g.logger.WithFields(logging.Fields{
			"error":   err.Error(),
			"content": fullFileContent.String(),
		}).Debug("Format buffer failed")
		return err
	}
	if _, err = f.Write(buffer); err != nil {
		return err
	}
	return nil
}

func (g *GameData) displayMV(mv codegen.MemberVersioning) {
	for k, v := range mv {
		g.logger.WithFields(logging.Fields{
			"struct": k,
			"count":  len(v),
		}).Debug("Struct versioning entries")
	}
	g.logger.WithField("same_type", codegen.IsSameType(mv["GeneratedStructStarter0"][0].Order[0], mv["GeneratedStructStarter0"][1].Order[0], 0)).Debug("Type comparison result")
	for _, i := range mv["GeneratedStructStarter0"] {
		i.PrintOrderedMembers(g.logger)
	}
}

func (g *GameData) GenerateGoFiles() error {
	if _, err := os.Stat(generatedFolderBasePath); err == nil {
		if err = os.RemoveAll(generatedFolderBasePath); err != nil {
			return err
		}
	}
	//s1m1 := &codegen.Member{
	//	T: &codegen.CustomType{
	//		Name: "Slice",
	//		Pkg:  "*types",
	//		Type1: &codegen.StructInfo{
	//			Name: "s1_m1_m2",
	//			Members: map[string]*codegen.Member{
	//				"s1_m1_m2_m3": {
	//					T:    reflect.String,
	//					Name: "s1_m1_m2_m3",
	//				},
	//			},
	//			Order: []*codegen.Member{
	//				{
	//					T:    reflect.String,
	//					Name: "s1_m1_m2_m3",
	//				},
	//			},
	//		},
	//		ImportPath: importpath.CustomTypesPath,
	//	},
	//	Attr: nil,
	//	Name: "member1",
	//}
	//s1 := &codegen.StructInfo{
	//	Name: "S1",
	//	Members: map[string]*codegen.Member{
	//		"member1": s1m1,
	//	},
	//	Order: []*codegen.Member{
	//		s1m1,
	//	},
	//}
	//
	//s2m1 := &codegen.Member{
	//	T: &codegen.StructInfo{
	//		Name: "s2_m1_m2",
	//		Members: map[string]*codegen.Member{
	//			"s2_m1_m2_m3": {
	//				T:    reflect.String,
	//				Name: "s2_m1_m2_m3",
	//			},
	//		},
	//		Order: []*codegen.Member{
	//			{
	//				T:    reflect.String,
	//				Name: "s2_m1_m2_m3",
	//			},
	//		},
	//	},
	//	Attr: nil,
	//	Name: "member1",
	//}
	//s2 := &codegen.StructInfo{
	//	Name: "S2",
	//	Members: map[string]*codegen.Member{
	//		"member1": s2m1,
	//	},
	//	Order: []*codegen.Member{
	//		s2m1,
	//	},
	//}
	//
	//codegen.FixMembers(s1, s2)
	//s1.PrintOrderedMembers()
	////s2.PrintOrderedMembers()
	//os.Exit(0)

	for p := range g.fileData {
		g.logger.WithFields(logging.Fields{
			"theme":   p,
			"entries": len(g.fileData[p].elements),
		}).Debug("Processing thematics")
		for _, element := range g.fileData[p].elements {
			root := codegen.GenerateGoFiles(g.logger, element, false)
			//printer.Debugf("Path: %v", p)
			g.fileData[p].mergeMemberVersioning(codegen.RegisteredMembers)
			g.fileData[p].structInfos = append(g.fileData[p].structInfos, root)
		}
		//g.displayMV(g.fileData[p].mv)
		//printer.Debugf("Gonna fix this")
		codegen.FixRegisteredMembers(g.logger, g.fileData[p].mv)
		for _, r := range g.fileData[p].structInfos {
			gw := writer.NewGoWriter(g.logger, g.fileData[p].mv, false, strcase.ToSnake(p))
			if err := gw.WriteGoFile(generatedFolderBasePath+p, r); err != nil {
				log.Fatal(err)
			}
		}
	}
	return g.generateRegisteredTypeFile()
}

func DirectSafeCast[T any](s any) T {
	c, ok := s.(T)
	if !ok {
		log.Panicf("can't cast to %v", reflect.TypeOf(s).Name())
	}
	return c
}

func (g *GameData) ReadGameFiles() error {
	g.logger.WithField("themes", len(g.fileData)).Debug("Reading game files from generated structure")
	//for p, gt := range g.fileData {
	//	printer.Debugf("Thematic {{{F_RED}}}%s", p)
	//	if s, ok := generated_resources.GlobalGameData[p]; !ok {
	//		printer.PrintErrorSf("Path not registered: %v", p)
	//		return nil
	//	} else {
	//		for _, elem := range gt.elements {
	//			if err := unmarshal.Element(elem, s); err != nil {
	//				log.Fatal(err)
	//			}
	//		}
	//	}
	//}
	return nil
}
